import pigpio #importere pigpio, pigpio er et library som hjÃ¦lper med at kontrollere GPIo'er, fungere med alle versioner af Pi
import mariadb #importere mariadb library, som hjÃ¦lper scriptet med at forbinde til den rigtige maria database
import time #tids library, hjÃ¦lper med at tÃ¦lle i sekunder, kan ogsÃ¥ bruge dato og tid moduler

# --- FlowmÃ¥ler konfiguration ---
FLOW_PIN = 18 #Definere flowmÃ¥ler puls tÃ¦ller til pin 18
PULSES_PER_LITER = 450 # 450 Pulser er 1 liter,
pulse_count = 0 # TÃ¦ller hvor mange pulser den modtager, starter pÃ¥ 0
liter_total = 0.0 # Holder styr pÃ¥ hvor mange liter der er mÃ¥lt, starter ogsÃ¥ pÃ¥ 0

# --- Pulsregistrering ---
def pulse_callback(gpio, level, tick): #Bliver kaldt hvis der kommer en Ã¦dnring i flowmÃ¥leren
    global pulse_count #Global, gÃ¸r det muligt at Ã¦ndre pulse_count da det er en variabel
    if level == 0:  # faldende kant, hjÃ¦lper med at tÃ¦lle pulser, falder den fra 1 -> 0 tÃ¦ller den 1 puls som fortÃ¦ller mÃ¦ngden af vandgennemstrÃ¸mning        pulse_count += 1 #Ã˜ger puls tÃ¦lleren med 1

# --- OpsÃ¦t pigpio ---
pi = pigpio.pi() #Opretter forbindelse til pigpio, som gÃ¸r det muligt at styre GPIO pins
if not pi.connected: #Tjekker forbindelsen lykkedes eller ikke gÃ¸r, via software, om pigpio er aktiveret, ellers "sudo pigpiod"
    print("âŒ Kunne ikke forbinde til pigpio") #FortÃ¦ller at problemet er i pigpio og ikked andre steder
    exit() #Stopper programmet, da vi ikke kan fortsÃ¦tte uden pigpio

#Elektrisk opsÃ¦tning, hvordan skal pi'en opfÃ¸re sig nÃ¥r der kommer pulser.
pi.set_mode(FLOW_PIN, pigpio.INPUT) #Vi har ikke fortalt hvad pin 18 bruges til, her fortÃ¦ller vi at det er input
pi.set_pull_up_down(FLOW_PIN, pigpio.PUD_UP) #Aktivere en modstand(pull-up) sÃ¥ den ikke modtagere tilfÃ¦ldige signaler men et klart signal nÃ¥r den bru>cb = pi.callback(FLOW_PIN, pigpio.FALLING_EDGE, pulse_callback)#hver gang der kommer en puls, vil callback kalde efter denne funktion
#uden den her linje sker der intet nÃ¥r flowmÃ¥leren sender et signal

# --- Databasekonfiguration ---
db_config = { #Config, opretter en dictionary som er mulig at genbruge,
    "user": "admin", #Brugernavn til DB som matcher serveren
    "password": "admin",#Kodeord til DB brugeren
    "host": "152.115.77.165",#IP-Adressen til DB
    "port": 50110,#Porten som MariaDB lytter pÃ¥
    "database": "Ã¸lbord"#Nanvet pÃ¥ DB vi Ã¸nsker at oprette forbindelse til
}

def opdater_database(liter):  #nÃ¥r ny mÃ¥ling af liter bliver detekteret vil den forsÃ¸ge at opdatere
    #liter er argumentet af antallet mÃ¥lt siden sidste opdatering og gemmer derefter den nye "liter" funktion
    print(f"ğŸ“¡ Forbinder til database for at opdatere {liter:.3f} liter.")
    try:
      conn = mariadb.connect( #Opretter forbindelse til DB server
            user=db_config["user"], #Bruger user fra db_config
            password=db_config["password"],
            host=db_config["host"],
            port=db_config["port"],
            database=db_config["database"],
            connect_timeout=3  # timeout efter 3 sekunder for at undgÃ¥ netvÃ¦rksfejl
        )
        cur = conn.cursor() #Cursor bruges til at skrive i en SQL kommando, conn.cursor er sÃ¥ forbindelsen til SQL og og sende kommandoer
        cur.execute(
            "UPDATE drikke_logg SET liter_drukket = liter_drukket + ? WHERE id =1",
            (liter,)
        )
        #LÃ¦gger nye mÃ¦ngde liter til den eksiterende tal i 'liter_drukket'
        conn.commit()
        #Gemmer Ã¦ndring i DB
        conn.close()
        #Lukker forbindelsen til DB
        print(f"âœ”ï¸  Database opdateret med {liter:.3f} liter")
    except mariadb.Error as e:
        print(f"âŒ Fejl ved databaseopdatering: {e}")

# --- HovedlÃ¸kke ---
def main_loop(): #KÃ¸rer hele tiden og mÃ¥ler vandforbrug
    global pulse_count, liter_total #GÃ¸r det muligt at lÃ¦se og Ã¦ndre variablerne,
    print("ğŸ’§ Starter mÃ¥ling. Ctrl+C for at stoppe.")
    try:
        while True:
            start = pulse_count #Gemmer antal pulser ved starten af intervallet
            time.sleep(1) #MÃ¥le intervallet, hvor lang tid skal vi mÃ¥le pulser
            end = pulse_count #Gemmer antallet af pulser efter i dette tilfÃ¦lde 1 sekund
            pulses = end - start # Udregner hvor mange pulser der er kommet mellem slutningen og starten
            liter = pulses / PULSES_PER_LITER # Konvertere pulser til liter
            liter_total += liter #Ligger literne til det samlede forbrug

            # Vis terminalstatus uanset hvad
            print(f"ğŸ”„ {pulses} pulser => {liter:.3f} liter | I alt: {liter_total:.3f} liter")
            #Hvis der bliver registreret 1 puls eller mere vil den opdater database liter eller
 if pulses > 0:
                opdater_database(liter)

    except KeyboardInterrupt:
        print("\nğŸ›‘ Stoppet af bruger.")
    finally:
        cb.cancel() #Stopper pigpio callback
        pi.stop() #Lukker pigpio forbindelse

if __name__ == "__main__": #hvis koden bliver kÃ¸rt direkte skal den kalde pÃ¥ main_loop
    #Hvis filen bliver startet i et andet program skal den bare stille funktionerne til rÃ¥dighed
    main_loop()
